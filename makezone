#!/usr/bin/perl

use strict;
use warnings;
use Carp;

our $version_number = "0.22i [11-JAN-11]";

########################################################################
#                           MAKEZONES                                  #
########################################################################

# Copyright (c), University of Cambridge, 1993, 1994, 1996
#
# The University retains the copyright and all other legal rights
# to this software and makes it available non-exclusively. All users
# must ensure that the software in all its derivations carries a
# copyright notice as above. No warranty is expressed or implied.

# This file is available for anonymous ftp from
#
# ftp.cus.cam.ac.uk:/pub/software/programs/DNS/makezones
#
# Enquires to Philip Hazel <ph10@cus.cam.ac.uk>.
#
# This version has been modified for CIDR network support
# by Christoph Weber-Fahr <wefa@gmx.de>
#
# This version has been modified for IPv6 support
# by Rudolf Polzer <rpolzer@mucke-novak.de>

########################################################################
# CONFIGURATION VARIABLES
#
# These are put at the top for ease of changing. See below for the full
# specification of the script.

# Makezones checks the characters used in the components of names. Different
# sites may have different my standards in this respect. The variable
# $name_pattern is used to contain a regular expression pattern that
# matches valid components of domain names. Change it to suit your
# requirements. Note that:
#
#  (a) The variable contains only the pattern characters, NOT the delimiting
#      slashes.
#  (b) This pattern is for one component only, so should not contain things
#      that match full stops (periods).
#  (c) The start and end of string metacharacters (^ and $) should not be
#      included; makezones uses this variable to build up a larger pattern
#      to match complete domain names, and it puts in ^ and $ itself.
#  (d) Because it is being constructed as a Perl string, any backslash
#      characters in the pattern must be doubled.

# This pattern specifies that names must start with a letter, contain only
# letters, digits, and hyphens, and not end with a hyphen.
my $name_pattern = '[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]([abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-]{0,61}[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])?';
#my $name_pattern = '[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]([abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789-]{0,61}[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789])?';

# Possible variations:
#
# $name_pattern = '[a-zA-Z\\d]([a-zA-Z\\-\\d]*[a-zA-Z\\d]+)?';  # digit at start
# $name_pattern = '[a-z]([a-z\\-\\d]*[a-z\\d]+)?';              # all lower case
#
# Note that, in addition to this, "*" is permitted as the first component of
# names on MX records, to allow MX wildcarding. Names for PTR records must
# always consist of four numeric components; $name_pattern is not used. Also,
# names on NS records may consist of numeric components - this is necessary
# in order to specify devolved reverse subzones.

# In a large zone it is very easy to accidentally reuse a name by mistake,
# or as the result of a typo. Makezones checks for duplicate names on A
# and PTR records unless the following variable is set to zero. When checking
# is enabled, it is possible to specify in the source file that certain
# duplicates are to be permitted. See the description of the DUP pseudo-
# RR below. Implied duplicates (i.e. records with no name, that take the
# name of their predecessor) do not cause errors.

my $duplicate_name_check = 1;

# To disable the checking of new zone file lengths against the previous
# versions, set $opt_short = 1 here. This forces the -short option for
# all runs. If a previous version does not exist when a check is required,
# a warning is output, but makezones does not fail.

my $opt_short = 0;

# If you want fields in WKS records to be checked against the contents
# of a file for validity, then set $services to the name of the file,
# and $grep to your favourite grep command. The values below will be
# typical. The program searches for the service name followed by a space
# or a tab at the start of a line. If you don't want this check, set
# $services to the null string.

my $services = "/etc/services";
my $grep     = "/usr/bin/egrep";

# If you want makezones to output some commentary as it goes along,
# to let you know it is making some progress, then set the $chatty
# variable to 1.

my $chatty = 1;
my $debug = ($ENV{MAKEZONE_DEBUG} ? 1 : 0);

# If you delegate zones for subnets with non-octet borders,
# there is a recommended way of doing this available as an internet
# draft (precisely said it deals with delegation of sub-class-c-nets).
# When doing this, you have to have an NS record for the subdomain
# as well as a CNAME record for every host in the delegated subnet
# pointing into the delegated domain. This Variable controls
# if this script creates these aliases automatically whenever
# it finds a delegation of the form XXX/YY.XXX.XXX.XXX

my $create_delegated_subnet_cnames = 1;

# this hook allows you to postprocess the zone files after successful
# generation. I use it to apply a simple beautifier script which
# I wrote a few years ago. Every zone file gets piped through
# $postprocess_command;

my $postprocess_zonefiles = 1;

#my $postprocess_command = "/usr/xpg4/bin/awk -f beautify.awk";
#my $postprocess_command = "/usr/bin/awk -f beautify.awk";
my $postprocess_command = "awk -f beautify.awk";

# allow wildcards of all types. If zero, only MX wildcards are possible
my $all_wildcards = 1;

########################################################################
# UNIX DEPENDENCIES
#
# The Unix "date" command is used to obtain the current date and time
# in a particular format.
#
# Perl's "stat" function is used to obtain the lengths of files; this may
# differ for other operating systems.
#
# Anything else I've forgotten?

########################################################################
#
# Makezones is a perl script for processing a source file for a DNS zone
# and producing the relevant operational DNS zone files. It does a lot of
# checking to ensure that the data is not bad, and it also ensures that
# the forward and reverse zone information is in step.
#
# Makezones handles the updating of the serial number automatically. It
# does this by updating the SOURCE FILE before generating the zone files.
#                >>>>>      NB NB NB NB      <<<<<
# The source file therefore has to be writeable. Makezones insists that
# the format of the serial number be <year><month><day><version> and that
# the year be four digits long, so that this code will continue to work
# after then end of 1999.
#
# Makezones originally handled only Class B and Class C networks, because
# those are the ones that are around here in Cambridge, UK. However, from
# version 0.20 it also handles Class A networks.
#
# Because the file should normally be correct, makezones makes no attempt
# attempt to continue if it finds a serious error. It just reports it and
# stops. However, syntax errors in the general records don't prevent it
# going on to check further records, so you can get more than one error
# message in a run. However, if it finds too many errors it says so, and
# gives up. "Too many" is currently more than ten.
#
# The input file looks like a normal DNS zone file, with the addition of
# the following rules, which impose additional restrictions. Some of these
# rules are to make it easy for makezones; some of them impose conventions
# that we use in Cambridge which might not be liked elsewhere. The code is
# well commented, and should be easy to modify.
#
#   . The class field ("IN") and the type fields ("A", "CNAME", etc.) must
#     be specified in upper case, as must "TCP" and "UDP" in WKS records.
#
#   . With the exception of the SOA & WKS records, all records must be
#     complete on one line of input. That is, continuation is not supported
#     in general.
#
#   . The SOA record must be right at the start of the file (except for blank
#     and comment lines), and must be set up so that each numeric parameter is
#     on a separate line. For example:
#
#     @    IN    SOA    cus.cam.ac.uk. hostmaster.ucs.cam.ac.uk. (
#                             1993080601      ; Serial
#                             10800           ; Refresh 3 hours
#                             3600            ; Retry 1 hour
#                             604800          ; Expire after a week
#                             86400 )         ; Minimum ttl
#
#     Makezones insists that the serial number be in this date-derived form.
#     Note that the serial number begins with the full year number, not just
#     the last two digits. The SOA record is expected to have the "IN" class
#     field; subsequent records may omit it.
#
#   . The NS records for the zone must appear at the top of the file, just
#     after the SOA record. These will be copied into the forward and the
#     reverse zone files. That is, the default assumption is that the name-
#     servers are the same for the forward and reverse zones. These NS records
#     must NOT have anything in the name field. The copying stops on reaching
#     the first record with a name field or the first non-NS record.
#
#   . Makezones can also cope with the case where there are different NS
#     records for the different zones. If an NS record at the top of the
#     file contains text after the nameserver name, this is taken as a list
#     of zones to which this NS record applies. For example,
#
#            IN    NS    abcd.some.domain.   some.domain.  144.44.0.0
#
#     The reverse zones are identified by their IP network numbers. If there
#     are a lot of them, multiple instances of this special kind of qualified
#     NS record can be used.
#
#   . NS records must always refer to fully qualified names. Makezones checks
#     for the final dot, because it is so easy to overlook this.
#
#   . Comment lines are not normally copied into the working zone files. They
#     can, however, be forced into them by the following syntax:
#
#     ;F   copy this comment line (without the F) into the forward file(s)
#     ;R   copy this comment line (without the R) into the reverse file(s)
#
#   . Comments that are attached to resource records are not copied over
#     into the zone files in most cases.
#
#   . All records except PTR records are normally copied to the forward file.
#     However, A records can be marked as "reverse only" by preceding them
#     with ">R " at the start. In this case, no A record is written to the
#     forward file, but a PTR record is constructed for the appropriate
#     reverse zone file. There should be exactly one space after the ">R";
#     three characters are removed from the start of the record. If ">R" is
#     followed by a tab, the tab is not removed (i.e. it acts as more than
#     one space).
#
#   . PTR records and A records are the only ones used when generating the
#     reverse zone files. "A" records can be marked "forwards only" by preced-
#     ing them with ">F " at the start. This suppresses generation of a PTR
#     record for the reverse zone. It does not, however, suppress the check
#     that the address is in one of the networks being handled (see next item
#     but one for external networks).
#
#   . When several IP addresses are associated with the same domain name,
#     multiple A records are required. Normally, the second and subsequent
#     ones should follow the first record, without a name of their own, thus
#     causing the previous name to be copied. If the same name is in fact
#     present on more than one A (or PTR) record, makezones' duplicate
#     check will pick it up and cause an error, unless (a) duplicate checking
#     has been entirely suppressed or (b) the name is listed in a DUP record.
#
#   . DUP records are something invented just for makezones; they are not
#     part of DNS zone files and do not cause anything to be written to the
#     output files. The format of a DUP record is:
#
#     domain-name      DUP
#
#     A DUP record tells makezones that its name is expected to appear on
#     more than one A or PTR record, and this is not an error. The DUP
#     record can appear in the file anywhere before the second record with
#     the given name. (Putting all the DUP records together near the top is
#     one way of keeping all this information in one place.)
#
#   . If more than one A record has the same IP address, there are four
#     possibilities:
#
#       (1) This is an error in the input.
#
#       (2) One name is considered "canonical" and reverse lookups on the
#           address should yield this name.
#
#       (3) Reverse lookups on the address should yield all of the names.
#
#       (4) Reverse lookups on the address should yield more than one (but not
#           all) of the names.
#
#     By default, makezones assumes case (1), because typos are really easy to
#     make when handling IP addresses. It therefore produces an error message
#     in cases such as this:
#
#       some.name       A  199.99.99.99
#       other.name      A  199.99.99.99
#
#     If case (2) applies, then all but one of the records must have the ">F "
#     flag, to ensure that only one PTR record is generated (for the canonical
#     name). Again, there must be exactly one space or a tab after ">F". For
#     example:
#
#       canon.name      A  199.99.99.99
#       >F other.name   A  199.99.99.99
#
#     If case (3) applies, then all the records, except (optionally) the
#     first, must have the ">M " flag, to tell makezones that multiple PTR
#     records are required. It is probably helpful to put the flag on the
#     first record as well, as a reminder that other records exist, especially
#     if they are separated in the input file. For example:
#
#       >M some.name    A  199.99.99.99
#       >M other.name   A  199.99.99.99
#
#     Case (4) is just a mixture of cases (2) and (3), with some records having
#     the ">M " flag and some the ">F " flag.
#
#   . The flag ">N " can be used to skip including an A or PTR record if it has
#     already been defined.
#
#   . The flag ">U " can be used define a record of unknown type. No checking
#     is done on its contents.
#
#   . We want to be able to check that all IP addresses are in one of the
#     networks that we are processing for. However, occasionally a record must
#     specify an external network (glue records are the prime example). Such
#     records must be flagged by ">E " at their start to override the error
#     that would otherwise occur. (They naturally won't get into any reverse
#     zones.) The special my address 127.0.0.1 is recognized and treated as
#     though ">E " is always present. The ">E " flag can be used on WKS
#     records as well as on A records.
#
#   . The name given for PTR records must be a complete, reversed IP address
#     that corresponds to one of the reverse zones. The network portion of
#     the "name" is removed when generating the PTR record for the reverse
#     zone.
#
#   . The ">M " flag may be used with PTR records if multiple entries
#     for the same IP address are required (see the comments about cases of
#     more than one name for the same IP number above). If this is done,
#     and the name (i.e. the reversed IP address) is explicitly quoted on
#     the second or subsequent records, it must also be listed in a DUP
#     record, unless duplicate checking is disabled.
#
#   . Very few PTR records should ever be necessary, but PTR records have to
#     be used instead of A records flagged with ">R " ("reverse only") when
#     the name pointed to is not in the domain of the forward zone, because
#     of the following rule:
#
#   . The names on all records must not end with . as we conventionally
#     specify them as partial domains for the forward zone. This means that,
#     if you want a record with the name of the zone as its domain, you must
#     use the "@" notation, which is supported.
#
#   . Makezones assumes that names consist of letters and digits, and start
#     with a letter. You can, however, override this by enclosing a name
#     in quotes. For example:
#
#     "3cpu"   A     134.232.45.69
#
#     I didn't want to allow these through normally, as in my zone they are
#     more likely to be typos. You can change the rules for what characters
#     are allowed in names (without quoting) by editing the variable
#     $name_pattern (see under CONFIGURATION VARIABLES at the head of this
#     file).
#
#   . There are occasions when you want to ensure that a name is *not*
#     present in your zone, for example, if you are reserving it for some
#     specific future use and don't want it used for something else by
#     mistake. The RESERVE record, which is a facility my to makezones,
#     can be used for this. If a record such as
#
#     do-not-use-me   RESERVE
#
#     is encountered by makezones, it performs its normal duplicate checking
#     on the name as if it were an A record, but generates no output from
#     this record.
#
#   . CNAME records must point to fully qualified names. Makezones checks
#     that if a name appears on a CNAME, it does not appear on any other
#     record.
#
#   . MX records must point to fully qualified names.
#
#
# Makezones is run by a command of the following form:
#
#   makezones [options] <source> <forward-zone> <forward-zone-file> \
#     [<reverse-zone-file>]*
#
# For example:
#
#   makezones  DBsource  cam.ac.uk  db.cam  db.131.111  db.192.153.213
#
# The source file is specified as the first argument. The second and third
# arguments specify the name of the zone and the file into which the records
# for that zone are to be written. The name is required so that fully
# qualified names can be generated in the reverse zone files. The remaining
# arguments specify the networks for which reverse zone files are to be
# written, and the corresponding files. There need not be any if there are
# no PTR or non-forwards-only A records in the source file. Each of these
# final arguments is the name of a zone file. The first part of the name can
# be anything you like - the only requirement is that the name must end with
# a valid Class A, Class B, or Class C network number.
#
# [This combining of network number and zone file name is done for convenience.
# To change makezones so that the numbers and file names are given as separate
# arguments would not be difficult; the changes would affect only the sub-
# routine that unpicks the arguments.]
#
# It is intended that makezones will normally be run as part of a "make"
# sequence which will also install the files and reload the nameserver(s)
# after makezones has run successfully. Thus, the command to run it will
# normally be stored in a file and not typed each time.
#
# The output files are actually written to temporary files whose names are the
# same as the final ones with ".new" appended. If the processing succeeds,
# these files are renamed; if it fails, they are deleted.
#
# Normally no options are required. There is currently only one option:
#
#   -short   Used when a new zone file is more than 5% shorter than the
#            previous version. If not given, the processing will fail if
#            a new file is that much shorter. This guards against the case
#            of accidental loss of large portions of the source file. Setting
#            -short disables the length checking for all zones. You do not
#            need to set this option if the previous versions of the files
#            do not exist, as in that case a warning is given, but makezones
#            continues. The script can be configured to default to -short; see
#            "configuration options" above.
#
# The input file must be writable. The first thing the script does is to update
# the serial number in the original file. This forms a permanent record and
# ensures that all the created zones have the same number. The form of the
# serial number must be <year><month><day><sequence>, as in the example SOA
# record shown above. The code will continue to work after December 31, 1999.
# If more than 99 updates are done in one day, the failure is soft in that a
# valid serial number is still generated, though it no longer contains that
# day's date.
#
#
# Written by Philip Hazel <ph10@cus.cam.ac.uk>
#   University Computing Service
#   Computer Laboratory
#   New Museums Site
#   Cambridge CB2 3QG
#   United Kingdom
#   +44 1223 334714
#
# Enhancements for non-octet subnet masks and some minor
# changes by Christoph Weber-Fahr <wefa@gmx.de>
#
# Started: August 1993
# Running: September 1993
#
# Update history:
#   0.03   07-Sep-93  I'd forgotten to allow TTLs on SOA records.
#   0.04   08-Sep-93  Allow comments before the SOA record.
#                     In several places, " " appeared in calls to split(),
#                       where "\s" should have appeared.
#                     Allow non-standard names in quotes. This lets in
#                       names like "3cpu" and "*.something".
#                     Treat tabs after >F etc as multiple spaces.
#                     Allow the name "@"; replace by zone name + dot.
#                     Allow omission of class field except on the SOA record.
#                     Check WKS address is in known network unless >E given.
#                     Fail broadcast addresses.
#   0.05   09-Sep-93  Use $name_pattern to check names.
#                     Permit "*" as first name component on MX records.
#   0.06   10-Sep-93  Failed if trailing spaces followed 127.0.0.1
#   0.06a  22-Sep-93  Updated the specification comments.
#   0.07   05-Nov-93  Added support for RP records.
#                     Added conditional facility for zone NS records.
#   0.08   09-Sep-94  Added the ">M " flag to permit multiple PTR records.
#                     Incorporated duplicate name checking and the DUP
#                       pseudo-record, and merged the CNAME check into
#                       this code as well. Uses an associative array, which
#                       will be large for large zones, but no larger than
#                       the existing one already used for addresses.
#                     Don't fail if previous version of a zone file does
#                       not exist (for length checking). Just say so.
#                     Support comments on the ends of all records.
#   0.09   01-Nov-94  Added /o to the pattern matches involving $name_pattern.
#                     Added the RESERVE record.
#   0.10   02-Nov-94  Some unrecorded change...
#   0.20   29-Jul-96  Added class A support.
#                     Changed "do sub" to "&sub" as "do" is deprecated in Perl 5
#                     Checked out with Perl 5.002
#   0.21   27-Feb-97  Allow for whitespace after ( in SOA record
#   0.22   03-Mar-97  Allow names on the rhs of records to have components
#                     that start with a digit without special notation
#   0.22b CWF Jun-97  Badly documented hacks to implement handling of
#		      non-octet-boundary networks (CIDR). See coments
#                     with [CWF]
#   0.22c CWF Nov-03  Added rudimentary SRV support (just copy, no checks)
#		      Imported $TTL handling from Phil Hazel's makezone-0.33
#   0.22d CWF Jan-04  Fixed newline handling with trailing comments,
#		      fixed PTR network check
#   0.22e CWF Aug-04  Extended SRV Support for equally rudimentary NAPTR support
#   0.22f CWF Dec-04  Fixed bug with zero-record files
#   0.22g CWF Apr-08  Added Wildcards of all types
#   0.22h CWF Jun-10  permitted wildcard consisting of "*" only
#   0.22i RP  Jan-11  IPv6 support
#

##################################################
#            Integer arithmetic                  #
##################################################

# All the arithmetic herein is integer, so tell Perl it can use
# integer operations. In fact, without this, the script falls over
# in Perl 5 because some of the numbers representing IP numbers
# use bit 31.

#use integer;

##################################################
#            Print error message and die         #
##################################################

# Ensure any temporary files are removed first. If reading the main file,
# $nline will be set non-zero and the current line will be in $_.

my $nline;
my $source_file;

$SIG{__DIE__} = sub {
    &remove_temps();
    print "\n** Makezones: $_[0]";
    if ( defined $nline and $nline > 0 ) {
        print "   At line $nline of $source_file:\n";
        print "   $_";
    }
    print STDERR "** Processing abandoned.\n\n";
    exit 1;
};

sub give_up {
    if($debug) {
        Carp::confess @_, "\n";
    } else {
        die @_, "\n";
    }
}

##################################################
#       Print error message and continue         #
##################################################

# After too many errors, give up.

my $errors = 0;

$SIG{__WARN__} = sub {
    print "\n** Makezones: $_[0]";
    if ( $nline > 0 ) {
        print "   At line $nline of $source_file:\n";
        print "   $_";
    }
};

sub error {
    if($debug) {
        Carp::cluck @_, "\n";
    } else {
        warn @_, "\n";
    }
    if ( ++$errors > 10 ) {
        &remove_temps();
        die "\n** Makezones: too many errors - processing abandoned.\n\n";
    }
}

##################################################
#       Zone data structures                     #
##################################################

my @sourcefiles = ();

# each member is a hash with members file, handle

my @zone = ();

# each member is a hash with members file, name, handle, soasource

my @rzone = ();

# each member is a hash with members file, name, prefix, prefixlen, handle, soasource

my @rzone6 = ();

# each member is a hash with members file, name, prefix, prefixlen, handle, soasource

##################################################
#       Print line to all reverse zone files     #
##################################################

sub print_reverse {
    my ($i);
    for ( $i = 0 ; $i < scalar @rzone ; $i++ ) {
        my $handle = $rzone[$i]{handle};
        print $handle $_[0];
    }
    for ( $i = 0 ; $i < scalar @rzone6 ; $i++ ) {
        my $handle = $rzone6[$i]{handle};
        print $handle $_[0];
    }
}

sub print_forward {
    my ($i);
    for ( $i = 0 ; $i < scalar @zone ; $i++ ) {
        my $handle = $zone[$i]{handle};
        print $handle $_[0];
    }
}

##################################################
#   IPv4+6 support                               #
##################################################

my $ipv4_params = {
    words      => 4,
    bits       => 8,
    revbits    => 8,
    recordtype => "A",
    suffix     => "IN-ADDR.ARPA",
    rzone      => \@rzone
};
my $ipv6_params = {
    words      => 8,
    bits       => 16,
    revbits    => 4,
    recordtype => "AAAA",
    suffix     => "IP6.ARPA",
    rzone      => \@rzone6
};

sub match_prefix_ip {
    my ( $params, $addr, $net, $prefixlen ) = @_;
    my $different = 0;
    for ( 0 .. ( $params->{words} - 1 ) ) {
        my $a = $addr->[$_];
        my $n = $net->[$_];
        $different ||= ( $a != $n );
        my $cbits = $prefixlen - $params->{bits} * $_;
        $cbits = $params->{bits} if $cbits > $params->{bits};
        $cbits = 0 if $cbits < 0;
        next if $cbits == 0;
        if ( $cbits < $params->{bits} ) {
            $a >>= ( $params->{bits} - $cbits );
            $n >>= ( $params->{bits} - $cbits );
        }
        return 0 if $a != $n;
    }
    return $different ? 1 : 2;    # 2 means equal
}

sub bit_ip {
    my ( $params, $addr, $bit, $newvalue ) = @_;
    my $pos = ( $params->{words} - 1 ) - int( $bit / $params->{bits} );
    my $val = ( 1 << ( $bit % $params->{bits} ) );
    my $old = ( $addr->[$pos] & $val );
    if ( defined $newvalue ) {
        if ( $newvalue and not $old ) {
            $addr->[$pos] += $val;
        }
        elsif ( $old and not $newvalue ) {
            $addr->[$pos] -= $val;
        }
    }
    return $old;
}

sub increment_ip {
    my ( $params, $addr, $incbit, $incamount ) = @_;
    if ( $incamount > 1 ) {
        return increment_ip(
            $params,
            increment_ip( $params, $addr, $incbit + 1, int( $incamount / 2 ) ),
            $incbit,
            $incamount % 2
        );
    }
    elsif ( $incamount < 1 ) {
        return $addr;
    }
    else {

        # increment by ONE
        my $carry = 1;
        $addr = [@$addr];    # copy
        while ($carry) {
            $carry = bit_ip $params, $addr, $incbit;
            bit_ip $params, $addr, $incbit, !$carry;
        }
        return $addr;
    }
}

sub list_ip_noncidr {
    my ( $params, $prefix, $prefixlen ) = @_;
    return [ $prefix, $prefixlen ]
      if $prefixlen % $params->{revbits} == 0;
    my $newprefixlen =
      $prefixlen + $params->{revbits} - ( $prefixlen % $params->{revbits} );
    my $newprefix = $prefix;
    my $n = ( 1 << ( $newprefixlen - $prefixlen ) );
    return map {
        [
            increment_ip(
                $params, $newprefix,
                $params->{words} * $params->{bits} - $newprefixlen, $_
            ),
            $newprefixlen
        ]
    } 0 .. ( $n - 1 );
}

sub find_zone_ip {
    my ( $params, $subnet, @addr ) = @_;
    my ($rzone);

    my $bestzone = undef;

    for ( $rzone = 0 ; $rzone < scalar @{ $params->{rzone} } ; $rzone++ ) {
        my $cmp = match_prefix_ip $params, \@addr,
          $params->{rzone}[$rzone]{prefix}, $params->{rzone}[$rzone]{prefixlen};
        $bestzone = $rzone
          if $cmp
              && ( !defined $bestzone
                  || $params->{rzone}[$rzone]{prefix} >=
                  $params->{rzone}[$bestzone]{prefix} )
              && ( ( $subnet == 0 ) || ( $cmp != 2 ) );
    }

    return $bestzone;
}

sub cname_hack {
    my ( $subnet, $prefixlen ) = @_;

    if ( $subnet =~ /^(.*?)\.(.*)$/ ) {
        return "$1/$prefixlen.$2";
    }

    &error("cname hack but no dots?");
    return undef;
}

sub enddot {
    my ($name) = @_;
    return $name if $name eq "";
    return $name if $name =~ /\.$/;
    return "$name.";
}

##################################################
#   IPv4 support                                 #
##################################################

sub parse_v4 {
    my ($addr) = @_;
    my (@addr);

    &error("invalid ipv4 address: $addr")
      if $addr =~ /^$|[^0-9.]/;

    @addr = split /\./, $addr;
    push @addr, 0 while @addr < 4;
    &error("invalid ipv4 address: $addr")
      if @addr != 4;
    if ( grep { $_ < 0 || $_ > 255 } @addr ) {
        &error("IPv4 address contains component with value greater than ffff.");
        return;
    }
    return @addr;
}

sub format_v4_forward {
    my (@addr) = @_;
    return sprintf "%d.%d.%d.%d", @addr;
}

# format a v4 address as part of a given reverse zone (prefix, prefixlen)
# currently this supports only %8 zones!
sub format_v4_reverse_inzone {
    my ( $subprefix, $subprefixlen, $prefix, $prefixlen ) = @_;
    &error("Invalid prefixlen $prefixlen")
      if $prefixlen < 0 || $prefixlen > 32;
    &error("Invalid subprefixlen $subprefixlen")
      if $subprefixlen < 0 || $subprefixlen > 32;
    &error("$subprefixlen not inside the prefix $prefixlen")
      if $subprefixlen < $prefixlen
          || !match_prefix_v4( $subprefix, $prefix, $prefixlen );
    &error("currently no support for more than 8 bits granularity")
      if $prefixlen % 8 || $subprefixlen % 8;

    my @l = @$subprefix;
    if ( $subprefixlen == 32 ) {
        if ( $prefixlen == 0 ) {
            return join ".", reverse @l;
        }
        else {
            return join ".", reverse @l[ ( $prefixlen / 8 ) .. @l - 1 ];
        }
    }
    else {
        if ( $prefixlen == 0 ) {
            if ( $subprefixlen == 0 ) {
                return "";
            }
            else {
                return join ".", reverse @l[ 0 .. ( $subprefixlen / 8 - 1 ) ];
            }
        }
        else {
            return join ".",
              reverse @l[ ( $prefixlen / 8 ) .. ( $subprefixlen / 8 - 1 ) ];
        }
    }
}

sub match_prefix_v4 {
    return match_prefix_ip $ipv4_params, @_;
}

sub bit_v4 {
    return bit_ip $ipv4_params, @_;
}

sub increment_v4 {
    return increment_ip $ipv4_params, @_;
}

sub list_v4_noncidr {
    return list_ip_noncidr $ipv4_params, @_;
}

sub find_zone_v4 {
    return find_zone_ip $ipv4_params, @_;
}

##################################################
#   IPv6 support                                 #
##################################################

sub parse_v6 {
    my ($addr) = @_;
    my (@addr);

    &error("invalid ipv6 address: $addr")
      if $addr =~ /^$|[^0-9a-fA-F:]/;

    if ( $addr =~ /([0-9a-fA-F:]*)::([0-9a-fA-F:]*)/ ) {
        my ($addr_pre)  = $1;
        my ($addr_post) = $2;
        my (@addr_pre)  = map { hex $_ } split /:/, $addr_pre;
        my (@addr_post) = map { hex $_ } split /:/, $addr_post;
        &error("invalid ipv6 address: $addr\n")
          if @addr_pre + @addr_post > 8;
        @addr = ( @addr_pre, (0) x ( 8 - @addr_pre - @addr_post ), @addr_post );
    }
    else {
        @addr = map { hex $_ } split /:/, $addr;
        &error("invalid ipv6 address: $addr\n")
          if @addr != 8;
    }
    if ( grep { $_ < 0 || $_ > 65535 } @addr ) {
        &error("IPv6 address contains component with value greater than ffff.");
        return;
    }
    return @addr;
}

sub format_v6_forward {
    my (@addr) = @_;
    return sprintf "%x:%x:%x:%x:%x:%x:%x:%x", @addr;
}

# format a v6 address as part of a given reverse zone (prefix, prefixlen)
# currently this supports only %4 zones!
sub format_v6_reverse_inzone {
    my ( $subprefix, $subprefixlen, $prefix, $prefixlen ) = @_;
    &error("Invalid prefixlen $prefixlen")
      if $prefixlen < 0 || $prefixlen > 128;
    &error("Invalid subprefixlen $subprefixlen")
      if $subprefixlen < 0 || $subprefixlen > 128;
    &error("$subprefixlen not inside the prefix $prefixlen")
      if $subprefixlen < $prefixlen
          || !match_prefix_v6( $subprefix, $prefix, $prefixlen );
    &error("currently no support for more than 4 bits granularity")
      if $prefixlen % 4 || $subprefixlen % 4;
    my $s = join '.', split //,
      reverse sprintf "%04x%04x%04x%04x%04x%04x%04x%04x", @$subprefix;
    if ( $subprefixlen == 128 ) {

        if ( $prefixlen == 0 ) {
            return $s;
        }
        else {
            return substr $s, 0, -( ( $prefixlen / 4 ) * 2 );
        }
    }
    else {
        if ( $prefixlen == 0 ) {
            if ( $subprefixlen == 0 ) {
                return "";
            }
            else {
                return substr $s, -( ( $subprefixlen / 4 ) * 2 - 1 );
            }
        }
        else {
            return substr $s, -( ( $subprefixlen / 4 ) * 2 - 1 ),
              -( ( $prefixlen / 4 ) * 2 );
        }
    }
}

sub match_prefix_v6 {
    return match_prefix_ip $ipv6_params, @_;
}

sub bit_v6 {
    return bit_ip $ipv6_params, @_;
}

sub increment_v6 {
    return increment_ip $ipv6_params, @_;
}

sub list_v6_noncidr {
    return list_ip_noncidr $ipv6_params, @_;
}

sub find_zone_v6 {
    return find_zone_ip $ipv6_params, @_;
}

##################################################
#            Common again                        #
##################################################

sub parse_ip {
    my ( $params, @rest ) = @_;
    if ( $params eq $ipv4_params ) {
        return parse_v4 @rest;
    }
    elsif ( $params eq $ipv6_params ) {
        return parse_v6 @rest;
    }
    else {
        &give_up("Invalid call to parse_ip");
    }
}

sub format_ip_forward {
    my ( $params, @rest ) = @_;
    if ( $params eq $ipv4_params ) {
        return format_v4_forward @rest;
    }
    elsif ( $params eq $ipv6_params ) {
        return format_v6_forward @rest;
    }
    else {
        &give_up("Invalid call to format_ip_forward");
    }
}

sub format_ip_reverse_inzone {
    my ( $params, @rest ) = @_;
    if ( $params eq $ipv4_params ) {
        return format_v4_reverse_inzone @rest;
    }
    elsif ( $params eq $ipv6_params ) {
        return format_v6_reverse_inzone @rest;
    }
    else {
        &give_up("Invalid call to format_ip_reverse_inzone");
    }
}

##################################################
#            Unpick the argument list            #
##################################################

# Exit from the whole program on failure.

sub unpick_args_addzones {
    my ( $params, $file, $prefix, $prefixlen ) = @_;

    &give_up("bad prefix length $prefixlen")
      if ( $prefixlen < 0
        || $prefixlen >= $params->{bits} * $params->{words} );

    if ( $prefixlen > $params->{bits} * $params->{words} - $params->{revbits} )
    {

        # detect a "CNAME delegation"
        my $zone = ( $params->{rzone}[ scalar @{ $params->{rzone} } ] = {} );
        $zone->{prefix}    = $prefix;
        $zone->{prefixlen} = $prefixlen;
        $zone->{file}      = $file;
        my $subnet = format_ip_reverse_inzone(
            $params, $prefix,
            $params->{bits} * $params->{words},
            [ (0) x $params->{words} ], 0
        );
        my $subnet_name = cname_hack $subnet, $prefixlen;
        $zone->{name} = enddot($subnet_name) . $params->{suffix};
        $zone->{soasource} = scalar @sourcefiles;
    }
    else {

        # detect a "multi-NS delegation" and use multiple zone files then
        my @l = list_ip_noncidr $params, $prefix, $prefixlen;
        for (@l) {
            my $subnet =
              format_ip_reverse_inzone( $params, $_->[0], $_->[1],
                [ (0) x $params->{words} ], 0 );
            my $zone =
              ( $params->{rzone}[ scalar @{ $params->{rzone} } ] = {} );
            $zone->{prefix}    = $_->[0];
            $zone->{prefixlen} = $_->[1];
            $subnet =~ /^([^.]+)/;
            $zone->{file} = $file . ( @l == 1 ? "" : ".$1" );
            $zone->{name} = enddot($subnet) . $params->{suffix};
            $zone->{soasource} = scalar @sourcefiles;
        }
    }
}

sub unpick_args {
    @zone   = ();
    @rzone  = ();
    @rzone6 = ();

    # Handle options

    while (@ARGV) {
        $_ = shift @ARGV;
        if (/^-short$/) {
            $opt_short = 1;
        }
        elsif (/^-f$/) {

            # forward zone
            my $zone = ( $zone[ scalar @zone ] = {} );
            ( $zone->{name} = shift @ARGV ) =~
              s/\.$//;    # remove trailing dot if present
            $zone->{file} = shift @ARGV;
            $zone->{soasource} = scalar @sourcefiles;
        }
        elsif (/^-r$/) {

            # reverse zone(s)
            my ($addr) = shift @ARGV;
            my ($file) = shift @ARGV;
            if ( $addr =~ /^(.*:.*)\/(\d+)$/ )    # IPv6
            {
                my ( $v6addr, $prefixlen ) = ( $1, $2 );
                unpick_args_addzones( $ipv6_params, $file,
                    [ parse_v6($v6addr) ], $prefixlen );
            }
            elsif ( $addr =~
                /^(\d+)(?:\.(\d+)(?:\.(\d+)(?:\.(\d+))?)?)?(?:\/(\d+))?$/ )
            {
                my ( $a, $b, $c, $d, $prefixlen ) = (
                    $1,
                    $2 || 0,
                    $3 || 0,
                    $4 || 0,
                    defined $5 ? $5
                    : (
                          defined $4 ? 32
                        : defined $3 ? 24
                        : defined $2 ? 16
                        : 8
                    )
                );
                my $v4addr = "$a.$b.$c.$d";
                unpick_args_addzones( $ipv4_params, $file,
                    [ parse_v4($v4addr) ], $prefixlen );
            }
            else {
                &give_up("reverse zone $addr: illegal format");
            }
        }
        elsif (/^-/) {
            &give_up("unknown option \"$ARGV[0]\"");
        }
        else {
            push @sourcefiles, { file => $_ };
        }
    }

    &give_up("do not have a source file")
      if not @sourcefiles;
    $source_file = $sourcefiles[0]{file}; # temp
}

##################################################
#         Verify what we are going to do         #
##################################################

sub verify {
    print "\nMakezones $version_number\n";
    print "Generating DNS zone files from $source_file.\n";

    printf "  Forward zone file%s ", ( scalar @zone == 1 ) ? ": " : "s:";
    if ( scalar @zone > 0 ) {
        for ( my $i = 0 ; $i < scalar @zone ; $i++ ) {
            print " " x 22 if $i != 0;
            print "$zone[$i]{file} ($zone[$i]{name})\n";
        }
    }
    else { print "<none>\n"; }

    printf "  Reverse zone file%s ", ( scalar @rzone == 1 ) ? ": " : "s:";
    if ( scalar @rzone > 0 ) {
        for ( my $i = 0 ; $i < scalar @rzone ; $i++ ) {
            print " " x 22 if $i != 0;
            print "$rzone[$i]{file} ($rzone[$i]{name})\n";
        }
    }
    else { print "<none>\n"; }

    printf "  v6 Reverse zone file%s ", ( scalar @rzone6 == 1 ) ? ": " : "s:";

    if ( scalar @rzone6 > 0 ) {
        for ( my $i = 0 ; $i < scalar @rzone6 ; $i++ ) {
            print " " x 25 if $i != 0;
            print "$rzone6[$i]{file} ($rzone6[$i]{name})\n";
        }
    }
    else { print "<none>\n"; }
}

sub named_conf {
    print "\nnamed.conf example:\n";

    for ( my $i = 0 ; $i < scalar @zone ; $i++ ) {
        print
"zone \"$zone[$i]{name}\" {\n\ttype master;\n\tfile \"$zone[$i]{file}\";\n};\n";
    }

    for ( my $i = 0 ; $i < scalar @rzone ; $i++ ) {
        print
"zone \"$rzone[$i]{name}\" {\n\ttype master;\n\tfile \"$rzone[$i]{file}\";\n};\n";
    }

    for ( my $i = 0 ; $i < scalar @rzone6 ; $i++ ) {
        print
"zone \"$rzone6[$i]{name}\" {\n\ttype master;\n\tfile \"$rzone6[$i]{file}\";\n};\n";
    }
}

##################################################
#           Punycode IDNs                        #
##################################################

sub encode_punycode {
    my ($domain) = @_;
    return $domain
      if not defined $domain;
    return $domain
      if $domain !~ /[^\000-\176]/;
    eval '
        require Net::LibIDN;
        my $suffix = "";
        $suffix = $1
            if $domain =~ s/(".*)//;
        $domain =~ s{([^\000-\037 .]+)}{
            Net::LibIDN::idn_to_ascii($1, "utf-8");
        }ge;
        $domain .= $suffix;
        1;
    ' or die $@;
    return $domain;
}

sub getline($) {
    my ($fh) = @_;
    my $s = scalar <$fh>;
    return $s
      if not defined $s;
    # handle the >8 flag (unicode)
    $s = $1 . encode_punycode $2
      if $s =~ /^(>[A-Z0-9]*8[A-Z0-9]*)(.*)/;
    return $s;
}

##################################################
#           Update the serial number             #
##################################################

# This function also checks out the format of the SOA
# record at the top of the file. We require it to be split
# so that every field is on a different line.

my $soa_count;

sub update_serial {
    my ($i);
    print "\nUpdating the serial number in the source file...\n" if $chatty;
    open( my $source, "+<$source_file" )
      || &give_up(
        "unable to open $source_file for read/write (to update serial)");

    # Check out the first line as the start of the SOA data. Skip any
    # prior comments, counting them so that we know how many lines to
    # copy when copying the SOA data.

    for ( ; ; ) {
        $_ = getline $source;
        last if ( !/^\s*$/ && !/^\s*;/ && !/^\$TTL\s/ );
        $soa_count++;
    }

    my ( $host, $hostmaster );
    my ( $at, $rest ) = split( /\s+/, $_, 2 );
    my $ttl;
    if ( $rest =~ /^\d/ ) {
        ( $ttl, $host, $hostmaster ) =
          $rest =~ /^(\d+)\s+IN\s+SOA\s+(\S+)\s+(\S+)\s*\(\s*$/;
    }
    else {
        ( $host, $hostmaster ) = $rest =~ /^IN\s+SOA\s+(\S+)\s+(\S+)\s*\(\s*$/;
    }

    &give_up("malformed SOA record")
      if ( $at ne "@" || $host eq "" || $hostmaster eq "" );

    # Remember where to write the second line, read it, and fish
    # out the serial number.

    my ($pos) = tell $source;
    $_ = getline $source;
    my ( $indent, $value ) = /^(\s+)(\d{10})(\s*;.*|)$/;
    &give_up("malformed serial number line (line 2 of SOA)")
      if ( $value eq "" );

    # Check out the remaining lines of the SOA record

    for ( $i = 3 ; $i <= 6 ; $i++ ) {
        $_ = getline $source;
        my ($check) =
          ( $i == 6 ) ? /^\s+(\d+)\s*\)(\s*;.*|)$/ : /^\s+(\d+)(\s*;.*|)$/;
        &give_up("line $i of the SOA record is malformed") if ( $check eq "" );
    }

    # Calculate the serial number for the first update of
    # today, allowing for the impending millenium.

    my ($today_serial) = `date +20%y%m%d01`;
    $today_serial -= 100000000 if ( substr( $today_serial, 2, 2 ) > 90 );

    # remove possible trailing newline (FreeBSD > 3.x ) [CWF]
    $today_serial =~ s/\n//;

    # If the existing serial number is already >= today's
    # start, increment it by one. Otherwise use today's start.

    $value = ( $value >= $today_serial ) ? $value + 1 : $today_serial;

    # Re-write the start of the second record with the new serial number.

    seek( $source, $pos, 0 );
    print $source "$indent$value";
    close $source;
}

##################################################
#          Handle comment lines                  #
##################################################

sub handle_comment {
    if (/^;F /) {
        &print_forward( "; " . substr( $_, 3 ) );
    }
    elsif (/^;R /) {
        &print_reverse( "; " . substr( $_, 3 ) );
    }
}

##################################################
# Check final field is a fully-qualified name    #
##################################################

sub check_fqn {
    &error("$_[1] record must point to a valid, fully qualified name.")
      if ( $_[0] !~ /^($name_pattern\.)+$/ );
}

##################################################
#              Handle non-comment records        #
##################################################

# The record is stored in $_ on entry. Do not alter this, since it is
# reflected after an error message. However, is is permitted to read a
# continuation record into it (as is done for WKS handling).

my %names;
my %names_v6;
my %addresses;
my $used_other   = -999999;
my $used_reserve = -888888;
my $used_dup     = -777777;

# store whether the CIDR CNAME hack has been already done for this name
my %done_cidr_hack = ();

# Three associative arrays, %names, %names_v6 and %addresses, are used for checking
# on the duplication of names and addresses. The check for CNAME and
# other data is handled by the same mechanism. The values used in the
# %names array are:
#
#   n == undef          the name has not yet been seen
#   n > 0               the name has appeared on one A (or PTR) record
#   $used_dup < n < 0   the name has appeared on a CNAME record
#   $used_dup           the name has appeared on a DUP record
#   $used_reserve       the name has appeared on a RESERVE record
#   $used_other         the name has appeared on any other DNS record
#
# The named values are all large negative numbers.
#
# An appearance on an A or PTR record overrides $user_other, and an appearance
# on a DUP record overrides a value > 0 and $used_other. The first
# entry to $names is set up when handling the SOA record. The values
# used for A, PTR and CNAME records are the line numbers where the first
# instance occurred (for use in error messages); to distinguish CNAME
# records, the line number is negated.

my $lastname;
my $lastwaserror;
my $default_zone = 0;

sub normalize_name {
    my ($name) = @_;
    if($name =~ /^\d{1,3}(\/\d{1,2})?(\.\d{1,3})*(?:\.in-addr\.arpa\.)?$/i) {
        # d/mask.c.b.a[.in-addr.arpa] -> [a.b.c.d/mask]
        my @l = split /\./, $name;
        $name = join ".", reverse $name;
        $name = "[$name]";
    }
    if($name =~ /^([0-9a-f])(?:\/(\d{1,3}))?((?:\.[0-9a-f])*)(?:\.ip6\.arpa\.)?$/i)
    {
        # x/mask.x.x.x.x.x.x.x.x.x.x.x.x.x.ip6.arpa -> [x:x::x/mask]
        my $address = reverse "$1$2";
        my $mask = $3;

        $address =~ s/\.//g;
        $address =~ s/(....)(?!$)/$1:/g;
        $address .= "::/$mask";
        $name = "[$address]";
    }
    return $name;
}

sub handle_record($) {
    my ($source) = @_;
    my $forwards_only = 0;
    my $reverse_only = 0;
    my $external_net = 0;
    my $multiple = 0;
    my $ifndef = 0;
    my $allow_unknown = 0;

   # If the record starts with ">E ", ">F ", ">M ", ">N " or ">R " set flags for
   # later checks once the type of record is known, and remove these characters.
   # $forwards_only must always be set if $external_net is set. If ">E" etc. are
   # followed by a tab, this must be interpreted as if it were several spaces;
   # the right thing happens if the tab is not removed.

    my $flags = "";
    my $rest  = $_;
    if ( $rest =~ s/^>([A-Z0-9]*)(?=\s) ?// ) {
        $flags = $1;
    }
    if ( $flags =~ /8/ ) {
        # the unicdoe/punycode flag - it has been handled earlier already, so
        # no processing done here
    }
    if ( $flags =~ /E/ ) {
        $forwards_only = $external_net = 1;
    }
    if ( $flags =~ /F/ ) {
        $forwards_only = 1;
    }
    if ( $flags =~ /M/ ) {
        $multiple = 1;
    }
    if ( $flags =~ /N/ ) {
        $ifndef = 1;
    }
    if ( $flags =~ /R/ ) {
        $reverse_only = 1;
    }
    if ( $flags =~ /U/ ) {
        $allow_unknown = 1;
    }
    if ( $flags =~ /Z/ and $rest eq "" ) {
        undef $default_zone;
        return;
    }
    if ( $flags =~ /Z/ and $rest =~ /^\s*(.*)/ ) {
        my $name = $1;
        if (
            defined(
                my $i =
                  [ grep { $name eq $zone[$_]{name} } 0 .. scalar @zone - 1 ]
                  ->[0]
            )
          )
        {
            $default_zone = $i;
        }
        else {
            &error("Unknown zone $name.");
        }
        return;
    }

    # Split the line into the first field (name) and the rest
    # of the line. Name is null if the line starts with a space.
    # In this case, set it to the value from the previous record,
    # but set the printing name to blanks so it isn't output.
    # We still use split() in this case, because it gets rid
    # of the leading spaces on the remainder of the line.

    ( my $name, $rest ) = split( /\s+/, $rest, 2 );
    my $printname;
    if ( $name eq "" ) {
        $name      = $lastname;
        $printname = "  ";
    }
    else {
        $printname = $name;
        $lastname  = $name;
    }

    # If $name is null, it means we have hit a record without a name
    # field at the top of the file. In a zone file this would mean the
    # name of the zone, but we don't allow this laxness.

    if ( $name eq "" ) {
        &error(
            "missing name on the first record after initial SOA + NS records.");
        return;
    }

    # Split off the TTL field, if present. It must consist entirely
    # of digits.

    my $ttl;
    if ( $rest =~ /^\d/ ) {
        ( $ttl, $rest ) = split( /\s+/, $rest, 2 );
        if ( $ttl ne "" && $ttl !~ /^\d+$/ ) {
            &error("invalid TTL field (not all digits).");
            return;
        }
    }
    else { $ttl = ""; }

    # The class field may or may not be present. If not, the rule is to
    # copy it from the previous record, but we support only the "IN"
    # class anyway.

    ( my $class, $rest ) = split( /\s+/, $rest, 2 );
    my $type;
    if ( $class eq "IN" ) {
        ( $type, $rest ) = split( /\s+/, $rest, 2 );
    }
    else {
        $type  = $class;
        $class = "";
    }

    # Forward-only, reverse-only, external, and multiple flags may be
    # specified only for A records, except that >E may be specified for
    # WKS records, and >M for PTR records.

    if ( $multiple || $ifndef ) {
        &error(">M or >I may be specified only for type A or type PTR records.")
          if ( $type ne "A"
            && $type ne "AAAA"
            && $type ne "PTR"
            && $type ne "SRV" );
    }
    elsif ($external_net) {
        &error(">E may be specified only for type A and WKS records.")
          if ( $type ne "A"
            && $type ne "AAAA"
            && $type ne "WKS"
            && $type ne "SRV" );
    }
    else {
        &error(">F and >R may be specified only for type A records.")
          if ( ( $forwards_only || $reverse_only )
            && $type ne "A"
            && $type ne "AAAA" );
    }

    # If the name's components all consists of digits, it it taken as a
    # reversed IP address for inclusion in the reverse zone. Otherwise its
    # components must match the pattern set in the $name_pattern variable.
    # It may not end with a dot, as it is a subdomain name. Repeated names
    # get checked twice, but this isn't a great overhead.
    #
    # To allow for exceptions to the general $name_pattern check, we permit
    # names in double quotes. These are not checked at all.
    #
    # We must also allow the name "@" so that people can set up, for example,
    # MX records for their entire zone, and we allow the first component of
    # names on MX records to be "*".

    my $thiszone_name   = $zone[$default_zone]{name};
    my $thiszone_handle = $zone[$default_zone]{handle};
    for my $zi ( 0 .. @zone - 1 ) {
        my $zn = $zone[$zi]{name};
        if ( $name =~ s/\.\Q$zn\E\.$// ) {
            $thiszone_name   = $zn;
            $thiszone_handle = $zone[$zi]{handle};
            $printname =~ s/\.\Q$zn\E\.$//;
            last;
        }
    }

    my $fqdn;

    $name = normalize_name $name;

    if ( $name eq "@" ) {
        $name = "$thiszone_name.";
        $printname = $name if ( substr( $printname, 0, 1 ) ne " " );
    }
    elsif ( $name =~ /^\*/ ) {
        if ( $name !~ /^\*(\.$name_pattern)*$/o ) {
            &error( "invalid wildcard name field\n"
                  . "** (or other components do not match name pattern)." );

            $name = $lastname = "dummy";    # prevent subsequent errors
        }
        elsif ( ( $type ne "MX" ) && ( $all_wildcards == 0 ) ) {
            &error("wildcard names are permitted only on MX records.");
            $name = $lastname = "dummy";    # prevent subsequent errors
        }
    }
    elsif ( substr( $name, 0, 1 ) eq "\"" && substr( $name, -1 ) eq "\"" ) {
        $name = substr( $name, 1, length($name) - 2 );
        $printname = $name if ( substr( $printname, 0, 1 ) ne " " );
    }
    elsif ( $name =~ /^\[\d{1,3}(\.\d{1,3})*(?:\/\d{1,2})?\]$/ )
    {
        # Just check that this is on a PTR or NS or DUP record - full checking
        # of the name happens later for PTR & NS records.
        if ( $type ne "PTR" && $type ne "NS" && $type ne "DUP" ) {
            &error("invalid name field for this type of record.");
            $name = $lastname = "dummy";    # prevent subsequent errors
        }
        undef $fqdn; # FIXME
    }
    elsif ( $name =~ /^\[[0-9a-fA-F:]*:[0-9a-fA-F:]*(?:\/\d{1,3})?\]$/ ) {
        # Just check that this is on a PTR or NS or DUP record - full checking
        # of the name happens later for PTR & NS records.
        if ( $type ne "PTR" && $type ne "NS" && $type ne "DUP" ) {
            &error("invalid name field for this type of record.");
            $name = $lastname = "dummy";    # prevent subsequent errors
        }
        undef $fqdn; # FIXME
    }
    elsif ( $name !~ /^$name_pattern(\.$name_pattern)*$/o ) {
        # we ignore name pattern checks for srv and naptr records [CWF]
        if ( ( $type ne "SRV" ) && ( $type ne "NAPTR" ) ) {
            &error(
                "invalid name field $name (components do not match name pattern).");
            $name = $lastname = "dummy";    # prevent subsequent errors
        }
    }

    if ( !defined $fqdn ) {
        if ( $name =~ /\.$/ ) {
            $fqdn = "$name";
        }
        else {
            $fqdn = "$name.$thiszone_name.";
        }
    }

    # If the name on this record previously appeared on a RESERVE
    # record, it is an error. Let processing continue, however, to
    # detect other errors.

    if ( $names{"$fqdn"} && $names{"$fqdn"} == $used_reserve ) {
        &error("$name appeared on a previous RESERVE record.");
    }

    # If the name on this record, explicit or implied, previously
    # appeared on a CNAME record, it is an error. Set the value back
    # to nothing, to prevent multiple complaints.

    if ( $names{"$fqdn"} && $names{"$fqdn"} < 0 && $names{"$fqdn"} > $used_dup )
    {
        my $temp = -$names{"$fqdn"};
        &error("$fqdn appears on a previous CNAME record (line $temp).");
        $names{"$fqdn"} = "";
    }

    # Now we perform individual check which depend on the
    # record's type field. We support only the following types:
    # A, NS, CNAME, PTR, HINFO, MX, TXT, WKS, RP, SRV, and the special
    # DUP (invented for makezones).

    # For all except TXT, we must ignore trailing spaces and anything
    # following the first semicolon on the line, since that introduces
    # a comment. This is not quite so simple for TXT, because of the
    # quotes, so we handle TXT separately.

    # Type TXT - arbitrary descriptive text, enclosed in double quotes

    if ( $type eq "TXT" ) {
        if ( $rest !~ /^\".*\"\s*(;.*)?$/ ) {
            &error("malformed TXT record - must use double quotes.");
        }
        print $thiszone_handle "$printname  $ttl  $class  TXT  $rest";
        $names{"$fqdn"} = $used_other if $names{"$fqdn"};
        return;
    }

    # Remove comments and trailing spaces for all other types. This also
    # removes the trailing newline.

    $rest =~ s/\s*(;.*)?$//;

    # make sure newline is really gone  [CWF 13.01.2004]
    $rest =~ s/\n//;

    # Type RESERVE - a locally invented feature to reserve a name for
    # future use. Complain if the name has been previously used; otherwise
    # set a value in the names array to reserve it.

    if ( $type eq "RESERVE" ) {
        &error("malformed RESERVE record (text after RESERVE).")
          if $rest !~ /^$/;
        if ( $names{"$fqdn"} ) {
            &error("reserved name $name previously used.");
        }
        else { $names{"$fqdn"} = $used_reserve; }
        return;
    }

    # Type A - host address; the address must be in one of the networks
    # being processed, unless it was flagged as an external network.

    my $do_a = sub {
        my ($params) = @_;
        my ($rzone);
        my (@addr) = parse_ip( $params, $rest );
        my ($addr_normalized) = format_ip_forward $params, @addr;

        if ( !$reverse_only ) {
            if ( $params eq $ipv4_params ) {
                my ($nn) = $names{"$fqdn"} || 0;
                if (   $duplicate_name_check
                    && $printname !~ /^\s*$/
                    && $nn > 0
                    && !$multiple )
                {
                    return
                      if $ifndef;
                    &error( "unexpected duplicate name.\n"
                          . "** The first occurrence was in line $nn." );
                }

                $names{"$fqdn"} = $nline if !$nn || $nn == $used_other;
            }
            else {
                my ($nn) = $names_v6{"$fqdn"} || 0;

                if (   $duplicate_name_check
                    && $printname !~ /^\s*$/
                    && $nn > 0
                    && !$multiple )
                {
                    return
                      if $ifndef;
                    &error( "unexpected duplicate name.\n"
                          . "** The first occurrence was in line $nn." );
                }

                $names_v6{"$fqdn"} = $nline      if !$nn;
                $names{"$fqdn"}    = $used_other if !$names{"$fqdn"};
            }
        }
        if ( $params eq $ipv4_params ) {

            # The loopback address is always treated as external
            $external_net = $forwards_only = 1
              if ( $addr_normalized eq "127.0.0.1" );
        }
        else {

            # The loopback address is always treated as external
            $external_net = $forwards_only = 1
              if $addr_normalized eq "0:0:0:0:0:0:0:1";
        }

        if ( !$forwards_only ) {
            if ( $addresses{"$addr_normalized"} && !$multiple ) {
                return
                  if $ifndef;
                &error(
"duplicate IP address $addr_normalized specified for a PTR record.\n"
                      . "** Use the >M flag if multiple PTR records are required.\n"
                      . "** The first occurrence was in line $addresses{$addr_normalized}."
                );
            }
        }

        # Check known network (& find network) unless external

        if ( !$external_net ) {
            $rzone = &find_zone_ip( $params, 0, @addr );

            if ( !defined $rzone ) {
                &error(
"IP address is not in a known network (use >E for externals)."
                );
                return;
            }
        }

        # Output the A record to the forward file, unless reverse-only record.

        print $thiszone_handle
          "$printname  $ttl  $class  $params->{recordtype}  $addr_normalized\n"
          if !$reverse_only;

        # If required, generate a PTR record for the reverse file. Check for
        # multiples, and complain unless the record is flagged as such.

        if ( !$forwards_only ) {

            # modified to support CIDR-Style networks
            my ($handle) = $params->{rzone}[$rzone]{handle};
            print $handle format_ip_reverse_inzone(
                $params,
                \@addr,
                $params->{words} * $params->{bits},
                $params->{rzone}[$rzone]{prefix},
                int( $params->{rzone}[$rzone]{prefixlen} / $params->{revbits} )
                  * $params->{revbits}
            );
            print $handle "  $ttl  $class  PTR  $name";
            print $handle ".$thiszone_name."
              if ( substr( $name, -1, 1 ) ne "." );
            print $handle "\n";
            $addresses{"$addr_normalized"} = $nline
              if !$addresses{"$addr_normalized"};
        }
    };

    if ( $type eq "A" ) {
        $do_a->($ipv4_params);
        return;
    }

    if ( $type eq "AAAA" ) {
        $do_a->($ipv6_params);
        return;
    }

    # Type CNAME - pointer to canonical name. We require the canonical
    # name to be fully qualified. We also want to check that any name
    # that is on a CNAME record does not also appear on any other records.
    # This is done via the %names associative array. If there was a previous
    # CNAME record, the error message has already been given (and the value
    # set back to null to prevent another one).

    if ( $type eq "CNAME" ) {
        my ($nn) = $names{"$fqdn"} || 0;
        &check_fqn( $rest, "CNAME" );
        if ( $nn == 0 ) {
            $names{"$fqdn"} = -$nline;
            print $thiszone_handle "$name  $ttl $class  CNAME  $rest\n";
        }
        else {
            if ( $nn > $used_dup ) {
                $nn = -$nn if $nn < 0;
                &error("$name appears on a previous record (line $nn).");
            }
            else {
                &error("$name appears on a previous record.");
            }
        }
        return;
    }

    # Type PTR - pointer to entity elsewhere in the DNS; used only
    # for explicit reverse-lookup entries when the name is not in
    # this forwards zone. The name must be a complete reversed
    # IP or IPv6 address.

    if ( $type eq "PTR" ) {
        my ( $net, $rzone );
        my ($nn) = $names{"$fqdn"} || 0;

        if ( $duplicate_name_check && $printname !~ /^\s*$/ && $nn > 0 ) {
            &error( "unexpected duplicate name.\n"
                  . "** The first occurrence was in line $nn." );
        }

        $names{"$fqdn"} = $nline if !$nn || $nn == $used_other;

        my $do_ptr = sub {
            my ( $params, $name, $rest ) = @_;
            my @addr = parse_ip $params, $name;
            my ($addr_normalized) = format_ip_forward $params, @addr;

            &check_fqn( $rest, "PTR" );

            $rzone = &find_zone_ip( $params, 0, @addr );

            if ( !defined $rzone ) {
                &error("wrong PTR: $net is not part of a known network.");
            }
            else {
                my $thisaddress = $addr_normalized;
                if ( $addresses{"$thisaddress"} && !$multiple ) {
                    return
                      if $ifndef;
                    &error(
"duplicate IP address $thisaddress specified for a PTR record.\n"
                          . "** Use the >M flag if multiple PTR records are required.\n"
                          . "** The first occurrence was in line $addresses{$thisaddress}."
                    );
                }
                else {
                    my ($handle) = $params->{rzone}[$rzone]{handle};
                    print $handle format_ip_reverse_inzone(
                        $params,
                        \@addr,
                        $params->{words} * $params->{bits},
                        $params->{rzone}[$rzone]{prefix},
                        $params->{rzone}[$rzone]{prefixlen}
                    );
                    print $handle "  $ttl  $class  PTR  $rest";
                    print $handle ".$thiszone_name."
                      if ( substr( $rest, -1, 1 ) ne "." );
                    print $handle "\n";
                    $addresses{"$thisaddress"} = $nline
                      if !$addresses{"$thisaddress"};
                }
            }
        };

        if ( $name =~ /^\[(.*:.*)\]$/ )    # IPv6
        {
            $do_ptr->( $ipv6_params, $1, $rest );
        }
        elsif ( $name =~ /^\[(.*)\]$/ ) {
            $do_ptr->( $ipv4_params, $1, $rest );
        }
        else {
            &error("unrecognized PTR record for $name");
        }

        return;
    }

    # Type DUP - a pseudo record invented for use by makezones,
    # specifying that the name is permitted to be duplicated on
    # A and PTR records. If this name appeared on a previous CNAME,
    # an error will already have been given. Further errors might
    # occur whether or not we override, so take the easy line.

    if ( $type eq "DUP" ) {
        &error("malformed DUP record (text after DUP).") if $rest !~ /^$/;
        $names{"$fqdn"} = $used_dup;
        return;
    }

    # The remaining record types are classified as "other" for the
    # purpose of remembering which names have been used. This is
    # purely for the CNAME check. If no type is set, set the conv-
    # entional value. This may be overridden by subsequent records
    # such as A or PTR.

    $names{"$fqdn"} = $used_other if !$names{"$fqdn"};

    # Type SRV -- right now we just copy it to output [CWF]

    if ( $type eq "SRV" ) {
        print $thiszone_handle "$name  $ttl $class  SRV  $rest\n";
        return;
    }

    # Type NAPTR -- right now we just copy it to output as well [CWF - AUG 04]

    if ( $type eq "NAPTR" ) {
        print $thiszone_handle "$name  $ttl $class  NAPTR  $rest\n";
        return;
    }

    # Type NS - identity of nameserver. As the zone's nameserver records were
    # processed at the top of the file, these are NS records for devolved sub-
    # zones. Check that the name is fully qualified (ends with dot).
    # Special handling for CIDR delegation zones of the form
    # $d/$e.$c.%b.$a.IN-ADDR.ARPA is added here. The form of the
    # Record for Reverse delegations is nor documented in the comments.
    #
    # therefore there are now three 'legal' forms of subnet delegation
    # NS records:
    #           $b.$a	IN	NS	xxxx
    #        $c.$b.$a	IN	NS	xxxx
    #  $d/$e.$c.$b.$a	IN	NS	xxxx

    if ( $type eq "NS" ) {
        &check_fqn( $rest, "NS" );

        # If the name starts with a digit, it must be the reversed address of
        # a devolved sub-zone of a Class A or Class B network.

        my $do_ns = sub {
            my ( $params, $addr, $prefixlen ) = @_;

            my ( $net, $rzone, $r_e );
            my ($cidr_extension) = 1;
            my @addr = parse_ip $params, $addr;

            if ( $prefixlen % $params->{revbits} == 0 ) {
                $cidr_extension = 0;
            }

            $rzone = &find_zone_ip( $params, 1, @addr );

            if ( !defined $rzone ) {
                &error("$addr/$prefixlen is not a subnet of a known network.");
            }
            elsif ($cidr_extension
                && $prefixlen <
                $params->{words} * $params->{bits} - $params->{revbits} )
            {    # multi NS
                my ($handle) = $params->{rzone}[$rzone]{handle};
                my @subnet_list = list_ip_noncidr $params, \@addr, $prefixlen;
                for (@subnet_list) {
                    my $subnet = format_ip_reverse_inzone(
                        $params, $_->[0], $_->[1],
                        $params->{rzone}[$rzone]{prefix},
                        $params->{rzone}[$rzone]{prefixlen}
                    );
                    print $handle "$subnet  $ttl  $class  NS  $rest\n";
                }
            }
            elsif ($cidr_extension) {    # CNAME hack
                my ($handle) = $params->{rzone}[$rzone]{handle};
                my @subnet_list = list_ip_noncidr $params, \@addr, $prefixlen;
                my $supernet = format_ip_reverse_inzone(
                    $params,
                    $subnet_list[0]->[0],
                    $subnet_list[0]->[1],
                    [ (0) x $params->{words} ], 0
                );
                my $supersubnet = format_ip_reverse_inzone(
                    $params,
                    $subnet_list[0]->[0],
                    $subnet_list[0]->[1],
                    $params->{rzone}[$rzone]{prefix},
                    $params->{rzone}[$rzone]{prefixlen}
                );
                print $handle cname_hack $supersubnet, $prefixlen;
                print $handle "  $ttl  $class  NS  $rest\n";
                my $chack = cname_hack $supernet, $prefixlen;
                if ( !$done_cidr_hack{$chack}++ ) {

                    for (@subnet_list) {
                        my $subnet = format_ip_reverse_inzone(
                            $params, $_->[0], $_->[1],
                            $params->{rzone}[$rzone]{prefix},
                            $params->{rzone}[$rzone]{prefixlen}
                        );
                        $subnet =~ /^([^.]+)/;
                        my $subnet_name = enddot("$1.$chack");
                        print $handle
"$subnet  $ttl  $class  CNAME  $subnet_name$params->{suffix}.\n";
                    }
                }
            }
            else {
                my ($handle) = $params->{rzone}[$rzone]{handle};
                my $subnet = format_ip_reverse_inzone(
                    $params, \@addr, $prefixlen,
                    $params->{rzone}[$rzone]{prefix},
                    $params->{rzone}[$rzone]{prefixlen}
                );
                print $handle "$subnet  $ttl  $class  NS  $rest\n";
            }
        };

        if ( $name =~ /^\[(.*:.*)\/(.*)\]$/ ) {
            $do_ns->( $ipv6_params, $1, $2 );
        }
        elsif ( $name =~
/^\[(\d+)(?:\.(\d+)(?:\.(\d+)(?:\.(\d+))?)?)?(?:\/(\d+))?\]$/
          )
        {
            my ( $a, $b, $c, $d, $prefixlen ) =
(
                $1,
                $2 || 0,
                $3 || 0,
                $4 || 0,
                $5
                  || ( defined $4 ? 32 : defined $3 ? 24 : defined $2 ? 16 : 8 ));
            $do_ns->( $ipv4_params, "$a.$b.$c.$d", $prefixlen );
        }

        # Otherwise this is a devolution from the main forwards zone

        else { print $thiszone_handle "$printname  $ttl  $class  NS  $rest\n"; }
        return;
    }

    # Type HINFO - host information; no further checking

    if ( $type eq "HINFO" ) {
        print $thiszone_handle "$printname  $ttl  $class  HINFO  $rest\n";
        return;
    }

    # Type MX - mail exchanger; there must be a preference and
    # a fully-qualified gateway name.

    if ( $type eq "MX" ) {
        my ( $pref, $gateway ) = split( /\s+/, $rest, 2 );
        &check_fqn( $gateway, "MX" );
        if ( $pref !~ /^\d+$/ ) {
            &error("invalid MX preference field (not all digits).");
        }
        print $thiszone_handle
          "$printname  $ttl  $class  MX  $pref  $gateway\n";
        return;
    }

    # Type WKS - well-known services. This commonly is continued onto
    # other lines, so we must handle continuations. Check the protocol
    # field is either TCP or UDP, then check all the services appear
    # in the $services file, if it is set (typically /etc/services).
    # Check the address is in a known network, unless external.

    if ( $type eq "WKS" ) {
        my ( $address, $proto, $rest ) = split( /\s+/, $rest, 3 );

        # Check the address

        if ( !$external_net ) {
            my ( $a, $b, $c, $d ) =
              $address =~ /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;

            if ( $a eq "" ) {
                &error("IP address on WKS record is incomplete");
                return;
            }

            if ( $a > 255 || $b > 255 || $c > 255 || $d > 255 ) {
                &error(
                    "IP address contains component with value greater than 255."
                );
                return;
            }

            my $net = ( $a << 24 ) | ( $b << 16 ) | ( $c << 8 ) | $d;

# NOTE: WKS records do not support IPv6 and are deprecated. So no v6 support here.
            my $rzone = &find_zone_ip( $ipv4_params, 0, [ $a, $b, $c, $d ] );

            if ( !$rzone ) {
                &error("$net is not a known network.");
            }
        }

        # Check the protocol

        if ( $proto ne "UDP" && $proto ne "TCP" ) {
            &error("protocol in WKS record must be \"UCP\" or \"TCP\".");
        }

        # Start of line prefix - the rest of the line is in $rest

        my $pref = "$printname  $ttl  $class  WKS  $address $proto";

        # Allow continuation bracket at start of list only

        my $continued;
        my $list;
        if ( substr( $rest, 0, 1 ) eq "(" ) {
            $continued = 1;
            ($list) = $rest =~ /^\(\s*(.+)$/;
        }
        else { $continued = 0; $list = $rest; }

        # Loop for handling continuation records

        for ( ; ; ) {
            while ( substr( $list, -1 ) eq "\n" ) { chop($list); }
            while ( substr( $list, -1 ) eq " " )  { chop($list); }

            # Loop for scanning the list of services

            while ( $list ne "" ) {
                my $servicename;
                if ( index( $list, " " ) >= 0 ) {
                    ( $servicename, $list ) = split( /\s+/, $list, 2 );
                }
                else {
                    $servicename = $list;
                    $list        = "";

                   # Check for closing bracket at end of line. It may or may not
                   # be preceded by a space.

                    if ( $continued && substr( $servicename, -1 ) eq ")" ) {
                        chop($servicename);
                        $continued = 0;
                    }
                }

                # Check the service if required. $servicename can be empty if
                # a closing bracket is preceded by a space.

                if ( "$services" ne "" && $servicename ne "" ) {
                    if (
                        system(
                            "$grep \'^$servicename\[ \t]\' $services >/dev/null"
                        ) / 256
                      )
                    {
                        &error("\"$servicename\" does not appear in $services");
                    }
                }
            }

            print $thiszone_handle "$pref  $rest\n";
            return if !$continued;

            # Read in the next line, which contains more services, for the
            # next time round this loop.

            $_ = getline $source;
            $nline++;
            ( $list, my $dummy ) = $_ =~ /^\s*([^;]+)(;.*)?$/;
            $rest = "$list";
            $pref = "  ";
        }
    }

    # Type RP (Responsible Person) - two domain names

    if ( $type eq "RP" ) {
        if ( $rest !~ /^\S+\s+\S+$/ ) {
            &error("malformed RP record - two fields required.");
        }
        print $thiszone_handle "$printname  $ttl  $class  RP  $rest\n";
        return;
    }

    # other type

    if ( $allow_unknown && $type =~ /^[A-Z0-9]*$/ ) {
        print $thiszone_handle "$printname  $ttl  $class  $type  $rest\n";
        return;
    }

    # Else we have a bad record

    &error("unknown record type $type.");
}

##################################################
#           Generate the zone data               #
##################################################

sub generate_zones {
    my ($i);

    $lastname = "";
    $nline    = 0;

    print "Generating the zone data...\n" if $chatty;

    # Open the input file

    open( my $source, "$source_file" )
      || &give_up("unable to open $source_file");

    # Open the output files

    for ( $i = 0 ; $i < scalar @zone ; $i++ ) {
        open( $zone[$i]{handle}, ">$zone[$i]{file}.new" )
          || &give_up("unable to open $zone[$i]{file}.new");
    }

    for ( $i = 0 ; $i < scalar @rzone ; $i++ ) {
        open( $rzone[$i]{handle}, ">$rzone[$i]{file}.new" )
          || &give_up("unable to open $rzone[$i]{file}.new");
    }

    for ( $i = 0 ; $i < scalar @rzone6 ; $i++ ) {
        open( $rzone6[$i]{handle}, ">$rzone6[$i]{file}.new" )
          || &give_up("unable to open $rzone6[$i]{file}.new");
    }

    # Copy the SOA record into all the output files

    for ( $nline = 1 ; $nline <= $soa_count ; $nline++ ) {
        $_ = getline $source;
        &print_forward($_);
        &print_reverse($_);
    }

    # Record the fact that the name "@" has been used, for a record
    # of type "other". This will stop a CNAME of that name.

    $names{"$_."} = $used_other for map { $_->{name} } @zone;

    # Copy all the NS records for these zones to all the outputs. Stop
    # on reaching a non-NS record or a record with a name field. Skip
    # blank lines, and handle comments as normal.

    # We extend the syntax of NS records by allowing a list of names
    # to follow the nameserver name. If this is present, it lists the
    # zones to which this nameserver applies. Reverse zones are identified
    # by their IP network numbers.
    # This is also sufficient for handling of non byte-aligned nets. (CWF)

    $nline--;
    for ( ; ; ) {
        last if !( $_ = getline $source );
        $nline++;
        if (/^;/) { &handle_comment(); next; }
        next if /^\s*$/;
        last if /^\S/;

        my ( $ttl, $class, $ns, $rest ) =
          /^\s+(\d+\s+|)(IN\s+|)NS\s+(\S+)(|\s+.+)$/;
        last if $ns eq "";
        &check_fqn( $ns, "NS" );

        $rest =~ s/^\s+//;          # strip leading white space
        $rest =~ s/\s*(;.*)?$//;    # strip trailing spaces and comments & NL
        if ( $rest eq "" ) {
            &print_forward($_);
            &print_reverse($_);
        }
        else {
            while ( $rest ne "" ) {
                ( my $zone, $rest ) = split( /\s+/, $rest, 2 );

                my $do_ns = sub {
                    my ( $params, $addr, $prefixlen ) = @_;

                    my ($i);
                    &error("bad prefix length $prefixlen")
                      if ( $prefixlen % $params->{revbits}
                        || $prefixlen <= 0
                        || $prefixlen >= $params->{words} * $params->{bits} );
                    my @addr = parse_ip $params, $1;
                    {
                        for ( $i = 0 ;
                            $i < scalar @{ $params->{rzone} } ; $i++ )
                        {
                            if (
                                $prefixlen == $params->{rzone}[$i]{prefixlen}
                                && match_prefix_v6 \@addr,
                                $params->{rzone}[$i]{prefix}, 128
                              )
                            {
                                my ($handle) = $params->{rzone}[$i]{handle};
                                print $handle "  $ttl  $class  NS  $ns\n";
                                last;
                            }
                        }
                        &error("unknown network number on NS record")
                          if $i >= scalar @rzone6;
                    }
                };

                if (
                    defined(
                        my $i = [
                            grep { $zone eq $zone[$_]{name} }
                              0 .. scalar @zone - 1
                          ]->[0]
                    )
                  )
                {
                    my $h = $zone[$i]{handle};
                    print $h "  $ttl  $class  NS  $ns\n";
                }
                elsif ( $zone =~ /(.*:.*)\/(\d+)/ )    # IPv6
                {
                    $do_ns->( $ipv6_params, $1, $2 );
                }
                elsif ( $zone =~
                    /^(\d+)(?:\.(\d+)(?:\.(\d+)(?:\.(\d+))?)?)?(?:\/(\d+))?$/ )
                {
                    my ( $a, $b, $c, $d, $prefixlen ) = (
                        $1,
                        $2 || 0,
                        $3 || 0,
                        $4 || 0,
                        $5
                          || (
                              defined $4 ? 32
                            : defined $3 ? 24
                            : defined $2 ? 16
                            : 8
                          )
                    );
                    $do_ns->( $ipv4_params, "$a.$b.$c.$d", $prefixlen );
                }
            }
        }
    }

    # OK, now we have the first general record in $_. We can now scan
    # the rest of the file, processing as required. We do a check on
    # the first character of the line, because it is easy in moments
    # of absent-mindedness to do silly things like put in comments with
    # a sharp sign character instead of a semicolon. Let through only
    # those characters that can legally begin a line.

    for ( ; ; ) {
        if ( !/^\s*$/ ) {
            if ( !/^[\[\s\d_a-zA-Z\;>\"@\*]/ ) {
                &error("invalid line - semicolon omitted?");
            }
            elsif ( substr( $_, 0, 1 ) eq ";" ) { &handle_comment(); }
            else                                { &handle_record($source); }
        }
        last if !( $_ = getline $source );
        $nline++;
    }

    # Close all the files

    close $source;
    for ( $i = 0 ; $i < scalar @zone ; $i++ )  { close( $zone[$i]{handle} ); }
    for ( $i = 0 ; $i < scalar @rzone ; $i++ ) { close( $rzone[$i]{handle} ); }
    for ( $i = 0 ; $i < scalar @rzone6 ; $i++ ) {
        close( $rzone6[$i]{handle} );
    }
}

##################################################
#           Compare new/old zone lengths         #
##################################################

sub check_length {
    my ( $length_old, $length_new, $length_diff );
    my ($name) = $_[0];

    if ( !-e $name ) {
        print "\n" if $lastwaserror;
        print "  " if $chatty;
        print
"Length of $name not checked - previous version of file does not exist\n";
        $lastwaserror = 0;
        return;
    }

    my @stat_data = stat($name);
    $length_old  = $stat_data[7];
    @stat_data   = stat("$name.new");
    $length_new  = $stat_data[7];
    $length_diff = $length_old - $length_new;

    if ( $length_diff > ( $length_old / 20 ) ) {
        &error( "$name.new is more than 5% shorter than $name.\n"
              . "** Use -short to override this check." );
        $lastwaserror = 1;
    }
    elsif ($chatty) {
        print "\n" if $lastwaserror;
        print "  Length of $name is OK\n";
        $lastwaserror = 0;
    }
}

sub compare_lengths {
    my ($i);
    print "Comparing lengths of old and new zone files...\n" if $chatty;
    $lastwaserror = 0;
    for ( $i = 0 ; $i < scalar @zone ; $i++ ) {
        &check_length("$zone[$i]{file}");
    }
    for ( $i = 0 ; $i < scalar @rzone ; $i++ ) {
        &check_length("$rzone[$i]{file}");
    }
    for ( $i = 0 ; $i < scalar @rzone6 ; $i++ ) {
        &check_length("$rzone6[$i]{file}");
    }
}

##################################################
#         Rename new zones to final names        #
##################################################

sub rename_zones {
    my ($i);
    my ($xt) = ".new";
    if ($postprocess_zonefiles) {
        my ($xt2) = ".new2";
        print "postprocessing the new zone files...\n"
          if $chatty;
        for ( $i = 0 ; $i < scalar @zone ; $i++ ) {
            print("\t$zone[$i]{file}\n") if $chatty;
            my $dummy =
              `$postprocess_command < $zone[$i]{file}$xt > $zone[$i]{file}$xt2`;
            &give_up("postprocessing failed with $zone[$i]{file}")
              if ( $? >> 8 );
            unlink("$zone[$i]{file}$xt");
        }
        for ( $i = 0 ; $i < scalar @rzone ; $i++ ) {
            print("\t$rzone[$i]{file}\n") if $chatty;
            my $dummy =
`$postprocess_command < $rzone[$i]{file}$xt > $rzone[$i]{file}$xt2`;
            &give_up("postprocessing failed with $rzone[$i]{file}")
              if ( $? >> 8 );
            unlink("$rzone[$i]{file}$xt");
        }
        for ( $i = 0 ; $i < scalar @rzone6 ; $i++ ) {
            print("\t$rzone6[$i]{file}\n") if $chatty;
            my $dummy =
`$postprocess_command < $rzone6[$i]{file}$xt > $rzone6[$i]{file}$xt2`;
            &give_up("postprocessing failed with $rzone6[$i]{file}")
              if ( $? >> 8 );
            unlink("$rzone6[$i]{file}$xt");
        }
        $xt = $xt2;
    }

    print "Renaming the new zone files to their final names...\n" if $chatty;
    for ( $i = 0 ; $i < scalar @zone ; $i++ ) {
        rename( "$zone[$i]{file}$xt", "$zone[$i]{file}" );
    }
    for ( $i = 0 ; $i < scalar @rzone ; $i++ ) {
        rename( "$rzone[$i]{file}$xt", "$rzone[$i]{file}" );
    }
    for ( $i = 0 ; $i < scalar @rzone6 ; $i++ ) {
        rename( "$rzone6[$i]{file}$xt", "$rzone6[$i]{file}" );
    }

}

##################################################
#           Remove temporary files               #
##################################################

# This is used to remove the temporary files if processing
# fails. It is not an error for the temps not to exist.

sub remove_temps {
    my ($i);
    for ( $i = 0 ; $i < scalar @zone ; $i++ ) {
        unlink "$zone[$i]{file}.new";
        unlink "$zone[$i]{file}.new2";
    }
    for ( $i = 0 ; $i < scalar @rzone ; $i++ ) {
        unlink "$rzone[$i]{file}.new";
        unlink "$rzone[$i]{file}.new2";
    }
    for ( $i = 0 ; $i < scalar @rzone6 ; $i++ ) {
        unlink "$rzone6[$i]{file}.new";
        unlink "$rzone6[$i]{file}.new2";
    }
}

##################################################
#                Main Program                    #
##################################################

# After any serious error, the script dies and does not
# return to the main code. Syntax errors etc. carry on,
# leaving $errors containing the count. Only generate_zones()
# and compare_lengths() handle errors in this way - all the
# other routines generate hard errors.

$errors    = 0;
$soa_count = 6;

# Get weaving...

&unpick_args();
&verify();
&named_conf() if $chatty;
&update_serial();
&generate_zones();
print "\n" if $errors > 0;

# No line number for subsequent error messages.

$nline = -1;

# If length checks successful, do renames and end happy.

if ( $errors == 0 ) {
    &compare_lengths() if !$opt_short;
    if ( $errors == 0 ) {
        &rename_zones();
        print "\nMakezones completed successfully.\n";
        exit 0;
    }
}

# Something didn't work out...

&remove_temps();
print "\n** Makezones failed.\n";
exit 99;

# End of makezones
